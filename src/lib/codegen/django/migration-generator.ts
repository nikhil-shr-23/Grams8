import {
  type AppEdge,
  type AppNode,
  type Column,
  type Diagram,
} from "@/lib/types";
import {
  escapeString,
  getDjangoFieldOptions,
  getDjangoFieldType,
  getDjangoOnDeleteAction,
  toDjangoModelName,
  toDjangoTableName,
} from "./django-helpers";

export interface DjangoMigrationOptions {
  timestamp?: string;
}

export interface DjangoMigrationFile {
  filename: string;
  content: string;
}

export function generateDjangoMigration(
  diagram: Diagram,
  _options: DjangoMigrationOptions = {}
): DjangoMigrationFile[] {
  const content = generateInitialMigrationContent(diagram);
  return [
    {
      filename: `0001_initial.py`,
      content,
    },
  ];
}

export function generateDjangoMigrationString(
  diagram: Diagram,
  options: DjangoMigrationOptions = {}
): string {
  const files = generateDjangoMigration(diagram, options);
  return files.map((f) => `# File: ${f.filename}\n\n${f.content}`).join("\n\n");
}

function topologicalSort(nodes: AppNode[], edges: AppEdge[]): AppNode[] {
  const sorted: AppNode[] = [];
  const inDegree = new Map<string, number>();
  const adj = new Map<string, string[]>();

  for (const node of nodes) {
    inDegree.set(node.id, 0);
    adj.set(node.id, []);
  }

  for (const edge of edges) {
    const source = edge.source;
    const target = edge.target;
    if (!adj.has(target)) adj.set(target, []);
    adj.get(target)!.push(source);
    inDegree.set(source, (inDegree.get(source) || 0) + 1);
  }

  const queue = nodes.filter((node) => inDegree.get(node.id) === 0);

  while (queue.length > 0) {
    const u = queue.shift()!;
    sorted.push(u);
    for (const v of adj.get(u.id) || []) {
      inDegree.set(v, inDegree.get(v)! - 1);
      if (inDegree.get(v) === 0) {
        const node = nodes.find((n) => n.id === v);
        if (node) queue.push(node);
      }
    }
  }

  if (sorted.length !== nodes.length) {
    console.warn(
      "Circular dependency detected in tables. Migration order may be incorrect."
    );
    return nodes
      .filter((n) => !sorted.find((s) => s.id === n.id))
      .concat(sorted);
  }

  return sorted;
}

function generateInitialMigrationContent(diagram: Diagram): string {
  const { nodes, edges } = diagram.data;
  const appName = "yourapp"; // Placeholder as requested

  const sortedNodes = topologicalSort(
    nodes.filter((n) => !n.data.isDeleted),
    edges
  );

  const operations: string[] = [];
  const enumOperations = generateEnumOperations(sortedNodes, diagram.dbType);
  operations.push(...enumOperations);

  const createModelOperations = sortedNodes.map((node) =>
    generateCreateModelOperation(node, nodes, edges, diagram.dbType, appName)
  );
  operations.push(...createModelOperations);

  const postOperations = generatePostOperations(sortedNodes, diagram.dbType);
  operations.push(...postOperations);

  const operationsStr = operations.join(",\n\n        ");
  const dateStr = new Date().toISOString().split("T")[0];

  return `# Generated by grams8 on ${dateStr}
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        ${operationsStr}
    ]
`;
}

function generateEnumOperations(
  nodes: AppNode[],
  dbType: "mysql" | "postgres"
): string[] {
  if (dbType !== "postgres") return [];
  const operations: string[] = [];
  const createdEnums = new Set<string>();

  for (const node of nodes) {
    for (const col of node.data.columns) {
      if (col.type.toUpperCase() === "ENUM" && col.enumValues) {
        const enumTypeName = `${toDjangoTableName(node.data.label)}_${
          col.name
        }_enum`;
        if (createdEnums.has(enumTypeName)) continue;

        const values = col.enumValues
          .split(",")
          .map((v) => `'${escapeString(v.trim())}'`)
          .join(", ");
        operations.push(`migrations.RunSQL(
            "CREATE TYPE ${enumTypeName} AS ENUM (${values});",
            reverse_sql="DROP TYPE IF EXISTS ${enumTypeName};"
        )`);
        createdEnums.add(enumTypeName);
      }
    }
  }
  return operations;
}

function generateCreateModelOperation(
  node: AppNode,
  allNodes: AppNode[],
  edges: AppEdge[],
  dbType: "mysql" | "postgres",
  appName: string
): string {
  const modelName = toDjangoModelName(node.data.label);
  const fields = node.data.columns
    .map((col) =>
      generateFieldDefinition(col, node, allNodes, edges, dbType, appName)
    )
    .join(",\n                ");

  const options: string[] = [
    `'db_table': '${toDjangoTableName(node.data.label)}'`,
  ];
  if (node.data.comment && dbType === "postgres") {
    options.push(`'db_table_comment': '${escapeString(node.data.comment)}'`);
  }

  return `migrations.CreateModel(
            name='${modelName}',
            fields=[
                ${fields}
            ],
            options={
                ${options.join(",\n                ")}
            },
        )`;
}

function generateFieldDefinition(
  col: Column,
  currentNode: AppNode,
  allNodes: AppNode[],
  edges: AppEdge[],
  dbType: "mysql" | "postgres",
  appName: string
): string {
  const getColumnId = (handleId?: string | null) => handleId?.split("-")[0];

  const edge = edges.find(
    (e) => e.source === currentNode.id && getColumnId(e.sourceHandle) === col.id
  );

  if (edge) {
    const targetNode = allNodes.find((n) => n.id === edge.target);
    if (!targetNode)
      return `('ERROR_unknown_fk_${col.name}', models.TextField())`;

    const targetModelName = toDjangoModelName(targetNode.data.label);
    const onDelete = getDjangoOnDeleteAction(edge.data?.relationship);
    const fieldClass = col.isUnique
      ? "models.OneToOneField"
      : "models.ForeignKey";

    const options: string[] = [
      `to='${appName}.${targetModelName}'`,
      `on_delete=${onDelete}`,
      `db_column='${col.name}'`,
    ];
    if (col.nullable) options.push("null=True", "blank=True");

    return `('${col.name}', ${fieldClass}(${options.join(", ")}))`;
  }

  const fieldType = getDjangoFieldType(col, dbType);
  const options = getDjangoFieldOptions(col, fieldType);
  return `('${col.name}', ${fieldType}(${options.join(", ")}))`;
}

function generatePostOperations(
  nodes: AppNode[],
  dbType: "mysql" | "postgres"
): string[] {
  const operations: string[] = [];
  for (const node of nodes) {
    const tableName = toDjangoTableName(node.data.label);
    const quote = dbType === "postgres" ? '"' : "`";

    if (node.data.indices) {
      for (const index of node.data.indices) {
        const columns = index.columns
          .map((colId) => {
            const col = node.data.columns.find((c) => c.id === colId);
            return col ? `${quote}${col.name}${quote}` : "";
          })
          .filter(Boolean)
          .join(", ");

        if (columns) {
          const unique = index.isUnique ? "UNIQUE" : "";
          operations.push(`migrations.RunSQL(
            'CREATE ${unique} INDEX ${quote}${index.name}${quote} ON ${quote}${tableName}${quote} (${columns});',
            reverse_sql='DROP INDEX IF EXISTS ${quote}${index.name}${quote};'
        )`);
        }
      }
    }
  }
  return operations;
}
